// Code generated by counterfeiter. DO NOT EDIT.
package s3fakes

import (
	"sync"

	"github.com/cloudfoundry/bosh-backup-and-restore/s3-config-validator/src/internal/s3"
)

type FakeClient struct {
	CanGetObjectVersionsStub        func(string) error
	canGetObjectVersionsMutex       sync.RWMutex
	canGetObjectVersionsArgsForCall []struct {
		arg1 string
	}
	canGetObjectVersionsReturns struct {
		result1 error
	}
	canGetObjectVersionsReturnsOnCall map[int]struct {
		result1 error
	}
	CanGetObjectsStub        func(string) error
	canGetObjectsMutex       sync.RWMutex
	canGetObjectsArgsForCall []struct {
		arg1 string
	}
	canGetObjectsReturns struct {
		result1 error
	}
	canGetObjectsReturnsOnCall map[int]struct {
		result1 error
	}
	CanListObjectVersionsStub        func(string) error
	canListObjectVersionsMutex       sync.RWMutex
	canListObjectVersionsArgsForCall []struct {
		arg1 string
	}
	canListObjectVersionsReturns struct {
		result1 error
	}
	canListObjectVersionsReturnsOnCall map[int]struct {
		result1 error
	}
	CanListObjectsStub        func(string) error
	canListObjectsMutex       sync.RWMutex
	canListObjectsArgsForCall []struct {
		arg1 string
	}
	canListObjectsReturns struct {
		result1 error
	}
	canListObjectsReturnsOnCall map[int]struct {
		result1 error
	}
	CanPutObjectsStub        func(string) error
	canPutObjectsMutex       sync.RWMutex
	canPutObjectsArgsForCall []struct {
		arg1 string
	}
	canPutObjectsReturns struct {
		result1 error
	}
	canPutObjectsReturnsOnCall map[int]struct {
		result1 error
	}
	IsUnversionedStub        func(string) error
	isUnversionedMutex       sync.RWMutex
	isUnversionedArgsForCall []struct {
		arg1 string
	}
	isUnversionedReturns struct {
		result1 error
	}
	isUnversionedReturnsOnCall map[int]struct {
		result1 error
	}
	IsVersionedStub        func(string) error
	isVersionedMutex       sync.RWMutex
	isVersionedArgsForCall []struct {
		arg1 string
	}
	isVersionedReturns struct {
		result1 error
	}
	isVersionedReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) CanGetObjectVersions(arg1 string) error {
	fake.canGetObjectVersionsMutex.Lock()
	ret, specificReturn := fake.canGetObjectVersionsReturnsOnCall[len(fake.canGetObjectVersionsArgsForCall)]
	fake.canGetObjectVersionsArgsForCall = append(fake.canGetObjectVersionsArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("CanGetObjectVersions", []interface{}{arg1})
	fake.canGetObjectVersionsMutex.Unlock()
	if fake.CanGetObjectVersionsStub != nil {
		return fake.CanGetObjectVersionsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.canGetObjectVersionsReturns
	return fakeReturns.result1
}

func (fake *FakeClient) CanGetObjectVersionsCallCount() int {
	fake.canGetObjectVersionsMutex.RLock()
	defer fake.canGetObjectVersionsMutex.RUnlock()
	return len(fake.canGetObjectVersionsArgsForCall)
}

func (fake *FakeClient) CanGetObjectVersionsCalls(stub func(string) error) {
	fake.canGetObjectVersionsMutex.Lock()
	defer fake.canGetObjectVersionsMutex.Unlock()
	fake.CanGetObjectVersionsStub = stub
}

func (fake *FakeClient) CanGetObjectVersionsArgsForCall(i int) string {
	fake.canGetObjectVersionsMutex.RLock()
	defer fake.canGetObjectVersionsMutex.RUnlock()
	argsForCall := fake.canGetObjectVersionsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) CanGetObjectVersionsReturns(result1 error) {
	fake.canGetObjectVersionsMutex.Lock()
	defer fake.canGetObjectVersionsMutex.Unlock()
	fake.CanGetObjectVersionsStub = nil
	fake.canGetObjectVersionsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) CanGetObjectVersionsReturnsOnCall(i int, result1 error) {
	fake.canGetObjectVersionsMutex.Lock()
	defer fake.canGetObjectVersionsMutex.Unlock()
	fake.CanGetObjectVersionsStub = nil
	if fake.canGetObjectVersionsReturnsOnCall == nil {
		fake.canGetObjectVersionsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.canGetObjectVersionsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) CanGetObjects(arg1 string) error {
	fake.canGetObjectsMutex.Lock()
	ret, specificReturn := fake.canGetObjectsReturnsOnCall[len(fake.canGetObjectsArgsForCall)]
	fake.canGetObjectsArgsForCall = append(fake.canGetObjectsArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("CanGetObjects", []interface{}{arg1})
	fake.canGetObjectsMutex.Unlock()
	if fake.CanGetObjectsStub != nil {
		return fake.CanGetObjectsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.canGetObjectsReturns
	return fakeReturns.result1
}

func (fake *FakeClient) CanGetObjectsCallCount() int {
	fake.canGetObjectsMutex.RLock()
	defer fake.canGetObjectsMutex.RUnlock()
	return len(fake.canGetObjectsArgsForCall)
}

func (fake *FakeClient) CanGetObjectsCalls(stub func(string) error) {
	fake.canGetObjectsMutex.Lock()
	defer fake.canGetObjectsMutex.Unlock()
	fake.CanGetObjectsStub = stub
}

func (fake *FakeClient) CanGetObjectsArgsForCall(i int) string {
	fake.canGetObjectsMutex.RLock()
	defer fake.canGetObjectsMutex.RUnlock()
	argsForCall := fake.canGetObjectsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) CanGetObjectsReturns(result1 error) {
	fake.canGetObjectsMutex.Lock()
	defer fake.canGetObjectsMutex.Unlock()
	fake.CanGetObjectsStub = nil
	fake.canGetObjectsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) CanGetObjectsReturnsOnCall(i int, result1 error) {
	fake.canGetObjectsMutex.Lock()
	defer fake.canGetObjectsMutex.Unlock()
	fake.CanGetObjectsStub = nil
	if fake.canGetObjectsReturnsOnCall == nil {
		fake.canGetObjectsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.canGetObjectsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) CanListObjectVersions(arg1 string) error {
	fake.canListObjectVersionsMutex.Lock()
	ret, specificReturn := fake.canListObjectVersionsReturnsOnCall[len(fake.canListObjectVersionsArgsForCall)]
	fake.canListObjectVersionsArgsForCall = append(fake.canListObjectVersionsArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("CanListObjectVersions", []interface{}{arg1})
	fake.canListObjectVersionsMutex.Unlock()
	if fake.CanListObjectVersionsStub != nil {
		return fake.CanListObjectVersionsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.canListObjectVersionsReturns
	return fakeReturns.result1
}

func (fake *FakeClient) CanListObjectVersionsCallCount() int {
	fake.canListObjectVersionsMutex.RLock()
	defer fake.canListObjectVersionsMutex.RUnlock()
	return len(fake.canListObjectVersionsArgsForCall)
}

func (fake *FakeClient) CanListObjectVersionsCalls(stub func(string) error) {
	fake.canListObjectVersionsMutex.Lock()
	defer fake.canListObjectVersionsMutex.Unlock()
	fake.CanListObjectVersionsStub = stub
}

func (fake *FakeClient) CanListObjectVersionsArgsForCall(i int) string {
	fake.canListObjectVersionsMutex.RLock()
	defer fake.canListObjectVersionsMutex.RUnlock()
	argsForCall := fake.canListObjectVersionsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) CanListObjectVersionsReturns(result1 error) {
	fake.canListObjectVersionsMutex.Lock()
	defer fake.canListObjectVersionsMutex.Unlock()
	fake.CanListObjectVersionsStub = nil
	fake.canListObjectVersionsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) CanListObjectVersionsReturnsOnCall(i int, result1 error) {
	fake.canListObjectVersionsMutex.Lock()
	defer fake.canListObjectVersionsMutex.Unlock()
	fake.CanListObjectVersionsStub = nil
	if fake.canListObjectVersionsReturnsOnCall == nil {
		fake.canListObjectVersionsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.canListObjectVersionsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) CanListObjects(arg1 string) error {
	fake.canListObjectsMutex.Lock()
	ret, specificReturn := fake.canListObjectsReturnsOnCall[len(fake.canListObjectsArgsForCall)]
	fake.canListObjectsArgsForCall = append(fake.canListObjectsArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("CanListObjects", []interface{}{arg1})
	fake.canListObjectsMutex.Unlock()
	if fake.CanListObjectsStub != nil {
		return fake.CanListObjectsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.canListObjectsReturns
	return fakeReturns.result1
}

func (fake *FakeClient) CanListObjectsCallCount() int {
	fake.canListObjectsMutex.RLock()
	defer fake.canListObjectsMutex.RUnlock()
	return len(fake.canListObjectsArgsForCall)
}

func (fake *FakeClient) CanListObjectsCalls(stub func(string) error) {
	fake.canListObjectsMutex.Lock()
	defer fake.canListObjectsMutex.Unlock()
	fake.CanListObjectsStub = stub
}

func (fake *FakeClient) CanListObjectsArgsForCall(i int) string {
	fake.canListObjectsMutex.RLock()
	defer fake.canListObjectsMutex.RUnlock()
	argsForCall := fake.canListObjectsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) CanListObjectsReturns(result1 error) {
	fake.canListObjectsMutex.Lock()
	defer fake.canListObjectsMutex.Unlock()
	fake.CanListObjectsStub = nil
	fake.canListObjectsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) CanListObjectsReturnsOnCall(i int, result1 error) {
	fake.canListObjectsMutex.Lock()
	defer fake.canListObjectsMutex.Unlock()
	fake.CanListObjectsStub = nil
	if fake.canListObjectsReturnsOnCall == nil {
		fake.canListObjectsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.canListObjectsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) CanPutObjects(arg1 string) error {
	fake.canPutObjectsMutex.Lock()
	ret, specificReturn := fake.canPutObjectsReturnsOnCall[len(fake.canPutObjectsArgsForCall)]
	fake.canPutObjectsArgsForCall = append(fake.canPutObjectsArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("CanPutObjects", []interface{}{arg1})
	fake.canPutObjectsMutex.Unlock()
	if fake.CanPutObjectsStub != nil {
		return fake.CanPutObjectsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.canPutObjectsReturns
	return fakeReturns.result1
}

func (fake *FakeClient) CanPutObjectsCallCount() int {
	fake.canPutObjectsMutex.RLock()
	defer fake.canPutObjectsMutex.RUnlock()
	return len(fake.canPutObjectsArgsForCall)
}

func (fake *FakeClient) CanPutObjectsCalls(stub func(string) error) {
	fake.canPutObjectsMutex.Lock()
	defer fake.canPutObjectsMutex.Unlock()
	fake.CanPutObjectsStub = stub
}

func (fake *FakeClient) CanPutObjectsArgsForCall(i int) string {
	fake.canPutObjectsMutex.RLock()
	defer fake.canPutObjectsMutex.RUnlock()
	argsForCall := fake.canPutObjectsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) CanPutObjectsReturns(result1 error) {
	fake.canPutObjectsMutex.Lock()
	defer fake.canPutObjectsMutex.Unlock()
	fake.CanPutObjectsStub = nil
	fake.canPutObjectsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) CanPutObjectsReturnsOnCall(i int, result1 error) {
	fake.canPutObjectsMutex.Lock()
	defer fake.canPutObjectsMutex.Unlock()
	fake.CanPutObjectsStub = nil
	if fake.canPutObjectsReturnsOnCall == nil {
		fake.canPutObjectsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.canPutObjectsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) IsUnversioned(arg1 string) error {
	fake.isUnversionedMutex.Lock()
	ret, specificReturn := fake.isUnversionedReturnsOnCall[len(fake.isUnversionedArgsForCall)]
	fake.isUnversionedArgsForCall = append(fake.isUnversionedArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("IsUnversioned", []interface{}{arg1})
	fake.isUnversionedMutex.Unlock()
	if fake.IsUnversionedStub != nil {
		return fake.IsUnversionedStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.isUnversionedReturns
	return fakeReturns.result1
}

func (fake *FakeClient) IsUnversionedCallCount() int {
	fake.isUnversionedMutex.RLock()
	defer fake.isUnversionedMutex.RUnlock()
	return len(fake.isUnversionedArgsForCall)
}

func (fake *FakeClient) IsUnversionedCalls(stub func(string) error) {
	fake.isUnversionedMutex.Lock()
	defer fake.isUnversionedMutex.Unlock()
	fake.IsUnversionedStub = stub
}

func (fake *FakeClient) IsUnversionedArgsForCall(i int) string {
	fake.isUnversionedMutex.RLock()
	defer fake.isUnversionedMutex.RUnlock()
	argsForCall := fake.isUnversionedArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) IsUnversionedReturns(result1 error) {
	fake.isUnversionedMutex.Lock()
	defer fake.isUnversionedMutex.Unlock()
	fake.IsUnversionedStub = nil
	fake.isUnversionedReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) IsUnversionedReturnsOnCall(i int, result1 error) {
	fake.isUnversionedMutex.Lock()
	defer fake.isUnversionedMutex.Unlock()
	fake.IsUnversionedStub = nil
	if fake.isUnversionedReturnsOnCall == nil {
		fake.isUnversionedReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.isUnversionedReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) IsVersioned(arg1 string) error {
	fake.isVersionedMutex.Lock()
	ret, specificReturn := fake.isVersionedReturnsOnCall[len(fake.isVersionedArgsForCall)]
	fake.isVersionedArgsForCall = append(fake.isVersionedArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("IsVersioned", []interface{}{arg1})
	fake.isVersionedMutex.Unlock()
	if fake.IsVersionedStub != nil {
		return fake.IsVersionedStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.isVersionedReturns
	return fakeReturns.result1
}

func (fake *FakeClient) IsVersionedCallCount() int {
	fake.isVersionedMutex.RLock()
	defer fake.isVersionedMutex.RUnlock()
	return len(fake.isVersionedArgsForCall)
}

func (fake *FakeClient) IsVersionedCalls(stub func(string) error) {
	fake.isVersionedMutex.Lock()
	defer fake.isVersionedMutex.Unlock()
	fake.IsVersionedStub = stub
}

func (fake *FakeClient) IsVersionedArgsForCall(i int) string {
	fake.isVersionedMutex.RLock()
	defer fake.isVersionedMutex.RUnlock()
	argsForCall := fake.isVersionedArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) IsVersionedReturns(result1 error) {
	fake.isVersionedMutex.Lock()
	defer fake.isVersionedMutex.Unlock()
	fake.IsVersionedStub = nil
	fake.isVersionedReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) IsVersionedReturnsOnCall(i int, result1 error) {
	fake.isVersionedMutex.Lock()
	defer fake.isVersionedMutex.Unlock()
	fake.IsVersionedStub = nil
	if fake.isVersionedReturnsOnCall == nil {
		fake.isVersionedReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.isVersionedReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.canGetObjectVersionsMutex.RLock()
	defer fake.canGetObjectVersionsMutex.RUnlock()
	fake.canGetObjectsMutex.RLock()
	defer fake.canGetObjectsMutex.RUnlock()
	fake.canListObjectVersionsMutex.RLock()
	defer fake.canListObjectVersionsMutex.RUnlock()
	fake.canListObjectsMutex.RLock()
	defer fake.canListObjectsMutex.RUnlock()
	fake.canPutObjectsMutex.RLock()
	defer fake.canPutObjectsMutex.RUnlock()
	fake.isUnversionedMutex.RLock()
	defer fake.isUnversionedMutex.RUnlock()
	fake.isVersionedMutex.RLock()
	defer fake.isVersionedMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ s3.Client = new(FakeClient)
