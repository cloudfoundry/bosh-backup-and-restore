// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"io"
	"sync"
	"time"

	"github.com/cloudfoundry/bosh-backup-and-restore/orchestrator"
)

type FakeBackup struct {
	AddChecksumStub        func(orchestrator.ArtifactIdentifier, orchestrator.BackupChecksum) error
	addChecksumMutex       sync.RWMutex
	addChecksumArgsForCall []struct {
		arg1 orchestrator.ArtifactIdentifier
		arg2 orchestrator.BackupChecksum
	}
	addChecksumReturns struct {
		result1 error
	}
	addChecksumReturnsOnCall map[int]struct {
		result1 error
	}
	AddFinishTimeStub        func(time.Time) error
	addFinishTimeMutex       sync.RWMutex
	addFinishTimeArgsForCall []struct {
		arg1 time.Time
	}
	addFinishTimeReturns struct {
		result1 error
	}
	addFinishTimeReturnsOnCall map[int]struct {
		result1 error
	}
	CalculateChecksumStub        func(orchestrator.ArtifactIdentifier) (orchestrator.BackupChecksum, error)
	calculateChecksumMutex       sync.RWMutex
	calculateChecksumArgsForCall []struct {
		arg1 orchestrator.ArtifactIdentifier
	}
	calculateChecksumReturns struct {
		result1 orchestrator.BackupChecksum
		result2 error
	}
	calculateChecksumReturnsOnCall map[int]struct {
		result1 orchestrator.BackupChecksum
		result2 error
	}
	CreateArtifactStub        func(orchestrator.ArtifactIdentifier) (io.WriteCloser, error)
	createArtifactMutex       sync.RWMutex
	createArtifactArgsForCall []struct {
		arg1 orchestrator.ArtifactIdentifier
	}
	createArtifactReturns struct {
		result1 io.WriteCloser
		result2 error
	}
	createArtifactReturnsOnCall map[int]struct {
		result1 io.WriteCloser
		result2 error
	}
	CreateMetadataFileWithStartTimeStub        func(time.Time) error
	createMetadataFileWithStartTimeMutex       sync.RWMutex
	createMetadataFileWithStartTimeArgsForCall []struct {
		arg1 time.Time
	}
	createMetadataFileWithStartTimeReturns struct {
		result1 error
	}
	createMetadataFileWithStartTimeReturnsOnCall map[int]struct {
		result1 error
	}
	DeploymentMatchesStub        func(string, []orchestrator.Instance) (bool, error)
	deploymentMatchesMutex       sync.RWMutex
	deploymentMatchesArgsForCall []struct {
		arg1 string
		arg2 []orchestrator.Instance
	}
	deploymentMatchesReturns struct {
		result1 bool
		result2 error
	}
	deploymentMatchesReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	FetchChecksumStub        func(orchestrator.ArtifactIdentifier) (orchestrator.BackupChecksum, error)
	fetchChecksumMutex       sync.RWMutex
	fetchChecksumArgsForCall []struct {
		arg1 orchestrator.ArtifactIdentifier
	}
	fetchChecksumReturns struct {
		result1 orchestrator.BackupChecksum
		result2 error
	}
	fetchChecksumReturnsOnCall map[int]struct {
		result1 orchestrator.BackupChecksum
		result2 error
	}
	GetArtifactByteSizeStub        func(orchestrator.ArtifactIdentifier) (int, error)
	getArtifactByteSizeMutex       sync.RWMutex
	getArtifactByteSizeArgsForCall []struct {
		arg1 orchestrator.ArtifactIdentifier
	}
	getArtifactByteSizeReturns struct {
		result1 int
		result2 error
	}
	getArtifactByteSizeReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	GetArtifactSizeStub        func(orchestrator.ArtifactIdentifier) (string, error)
	getArtifactSizeMutex       sync.RWMutex
	getArtifactSizeArgsForCall []struct {
		arg1 orchestrator.ArtifactIdentifier
	}
	getArtifactSizeReturns struct {
		result1 string
		result2 error
	}
	getArtifactSizeReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	ReadArtifactStub        func(orchestrator.ArtifactIdentifier) (io.ReadCloser, error)
	readArtifactMutex       sync.RWMutex
	readArtifactArgsForCall []struct {
		arg1 orchestrator.ArtifactIdentifier
	}
	readArtifactReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	readArtifactReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	SaveManifestStub        func(string) error
	saveManifestMutex       sync.RWMutex
	saveManifestArgsForCall []struct {
		arg1 string
	}
	saveManifestReturns struct {
		result1 error
	}
	saveManifestReturnsOnCall map[int]struct {
		result1 error
	}
	ValidStub        func() (bool, error)
	validMutex       sync.RWMutex
	validArgsForCall []struct {
	}
	validReturns struct {
		result1 bool
		result2 error
	}
	validReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeBackup) AddChecksum(arg1 orchestrator.ArtifactIdentifier, arg2 orchestrator.BackupChecksum) error {
	fake.addChecksumMutex.Lock()
	ret, specificReturn := fake.addChecksumReturnsOnCall[len(fake.addChecksumArgsForCall)]
	fake.addChecksumArgsForCall = append(fake.addChecksumArgsForCall, struct {
		arg1 orchestrator.ArtifactIdentifier
		arg2 orchestrator.BackupChecksum
	}{arg1, arg2})
	stub := fake.AddChecksumStub
	fakeReturns := fake.addChecksumReturns
	fake.recordInvocation("AddChecksum", []interface{}{arg1, arg2})
	fake.addChecksumMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBackup) AddChecksumCallCount() int {
	fake.addChecksumMutex.RLock()
	defer fake.addChecksumMutex.RUnlock()
	return len(fake.addChecksumArgsForCall)
}

func (fake *FakeBackup) AddChecksumCalls(stub func(orchestrator.ArtifactIdentifier, orchestrator.BackupChecksum) error) {
	fake.addChecksumMutex.Lock()
	defer fake.addChecksumMutex.Unlock()
	fake.AddChecksumStub = stub
}

func (fake *FakeBackup) AddChecksumArgsForCall(i int) (orchestrator.ArtifactIdentifier, orchestrator.BackupChecksum) {
	fake.addChecksumMutex.RLock()
	defer fake.addChecksumMutex.RUnlock()
	argsForCall := fake.addChecksumArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBackup) AddChecksumReturns(result1 error) {
	fake.addChecksumMutex.Lock()
	defer fake.addChecksumMutex.Unlock()
	fake.AddChecksumStub = nil
	fake.addChecksumReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBackup) AddChecksumReturnsOnCall(i int, result1 error) {
	fake.addChecksumMutex.Lock()
	defer fake.addChecksumMutex.Unlock()
	fake.AddChecksumStub = nil
	if fake.addChecksumReturnsOnCall == nil {
		fake.addChecksumReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addChecksumReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBackup) AddFinishTime(arg1 time.Time) error {
	fake.addFinishTimeMutex.Lock()
	ret, specificReturn := fake.addFinishTimeReturnsOnCall[len(fake.addFinishTimeArgsForCall)]
	fake.addFinishTimeArgsForCall = append(fake.addFinishTimeArgsForCall, struct {
		arg1 time.Time
	}{arg1})
	stub := fake.AddFinishTimeStub
	fakeReturns := fake.addFinishTimeReturns
	fake.recordInvocation("AddFinishTime", []interface{}{arg1})
	fake.addFinishTimeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBackup) AddFinishTimeCallCount() int {
	fake.addFinishTimeMutex.RLock()
	defer fake.addFinishTimeMutex.RUnlock()
	return len(fake.addFinishTimeArgsForCall)
}

func (fake *FakeBackup) AddFinishTimeCalls(stub func(time.Time) error) {
	fake.addFinishTimeMutex.Lock()
	defer fake.addFinishTimeMutex.Unlock()
	fake.AddFinishTimeStub = stub
}

func (fake *FakeBackup) AddFinishTimeArgsForCall(i int) time.Time {
	fake.addFinishTimeMutex.RLock()
	defer fake.addFinishTimeMutex.RUnlock()
	argsForCall := fake.addFinishTimeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBackup) AddFinishTimeReturns(result1 error) {
	fake.addFinishTimeMutex.Lock()
	defer fake.addFinishTimeMutex.Unlock()
	fake.AddFinishTimeStub = nil
	fake.addFinishTimeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBackup) AddFinishTimeReturnsOnCall(i int, result1 error) {
	fake.addFinishTimeMutex.Lock()
	defer fake.addFinishTimeMutex.Unlock()
	fake.AddFinishTimeStub = nil
	if fake.addFinishTimeReturnsOnCall == nil {
		fake.addFinishTimeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addFinishTimeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBackup) CalculateChecksum(arg1 orchestrator.ArtifactIdentifier) (orchestrator.BackupChecksum, error) {
	fake.calculateChecksumMutex.Lock()
	ret, specificReturn := fake.calculateChecksumReturnsOnCall[len(fake.calculateChecksumArgsForCall)]
	fake.calculateChecksumArgsForCall = append(fake.calculateChecksumArgsForCall, struct {
		arg1 orchestrator.ArtifactIdentifier
	}{arg1})
	stub := fake.CalculateChecksumStub
	fakeReturns := fake.calculateChecksumReturns
	fake.recordInvocation("CalculateChecksum", []interface{}{arg1})
	fake.calculateChecksumMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBackup) CalculateChecksumCallCount() int {
	fake.calculateChecksumMutex.RLock()
	defer fake.calculateChecksumMutex.RUnlock()
	return len(fake.calculateChecksumArgsForCall)
}

func (fake *FakeBackup) CalculateChecksumCalls(stub func(orchestrator.ArtifactIdentifier) (orchestrator.BackupChecksum, error)) {
	fake.calculateChecksumMutex.Lock()
	defer fake.calculateChecksumMutex.Unlock()
	fake.CalculateChecksumStub = stub
}

func (fake *FakeBackup) CalculateChecksumArgsForCall(i int) orchestrator.ArtifactIdentifier {
	fake.calculateChecksumMutex.RLock()
	defer fake.calculateChecksumMutex.RUnlock()
	argsForCall := fake.calculateChecksumArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBackup) CalculateChecksumReturns(result1 orchestrator.BackupChecksum, result2 error) {
	fake.calculateChecksumMutex.Lock()
	defer fake.calculateChecksumMutex.Unlock()
	fake.CalculateChecksumStub = nil
	fake.calculateChecksumReturns = struct {
		result1 orchestrator.BackupChecksum
		result2 error
	}{result1, result2}
}

func (fake *FakeBackup) CalculateChecksumReturnsOnCall(i int, result1 orchestrator.BackupChecksum, result2 error) {
	fake.calculateChecksumMutex.Lock()
	defer fake.calculateChecksumMutex.Unlock()
	fake.CalculateChecksumStub = nil
	if fake.calculateChecksumReturnsOnCall == nil {
		fake.calculateChecksumReturnsOnCall = make(map[int]struct {
			result1 orchestrator.BackupChecksum
			result2 error
		})
	}
	fake.calculateChecksumReturnsOnCall[i] = struct {
		result1 orchestrator.BackupChecksum
		result2 error
	}{result1, result2}
}

func (fake *FakeBackup) CreateArtifact(arg1 orchestrator.ArtifactIdentifier) (io.WriteCloser, error) {
	fake.createArtifactMutex.Lock()
	ret, specificReturn := fake.createArtifactReturnsOnCall[len(fake.createArtifactArgsForCall)]
	fake.createArtifactArgsForCall = append(fake.createArtifactArgsForCall, struct {
		arg1 orchestrator.ArtifactIdentifier
	}{arg1})
	stub := fake.CreateArtifactStub
	fakeReturns := fake.createArtifactReturns
	fake.recordInvocation("CreateArtifact", []interface{}{arg1})
	fake.createArtifactMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBackup) CreateArtifactCallCount() int {
	fake.createArtifactMutex.RLock()
	defer fake.createArtifactMutex.RUnlock()
	return len(fake.createArtifactArgsForCall)
}

func (fake *FakeBackup) CreateArtifactCalls(stub func(orchestrator.ArtifactIdentifier) (io.WriteCloser, error)) {
	fake.createArtifactMutex.Lock()
	defer fake.createArtifactMutex.Unlock()
	fake.CreateArtifactStub = stub
}

func (fake *FakeBackup) CreateArtifactArgsForCall(i int) orchestrator.ArtifactIdentifier {
	fake.createArtifactMutex.RLock()
	defer fake.createArtifactMutex.RUnlock()
	argsForCall := fake.createArtifactArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBackup) CreateArtifactReturns(result1 io.WriteCloser, result2 error) {
	fake.createArtifactMutex.Lock()
	defer fake.createArtifactMutex.Unlock()
	fake.CreateArtifactStub = nil
	fake.createArtifactReturns = struct {
		result1 io.WriteCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeBackup) CreateArtifactReturnsOnCall(i int, result1 io.WriteCloser, result2 error) {
	fake.createArtifactMutex.Lock()
	defer fake.createArtifactMutex.Unlock()
	fake.CreateArtifactStub = nil
	if fake.createArtifactReturnsOnCall == nil {
		fake.createArtifactReturnsOnCall = make(map[int]struct {
			result1 io.WriteCloser
			result2 error
		})
	}
	fake.createArtifactReturnsOnCall[i] = struct {
		result1 io.WriteCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeBackup) CreateMetadataFileWithStartTime(arg1 time.Time) error {
	fake.createMetadataFileWithStartTimeMutex.Lock()
	ret, specificReturn := fake.createMetadataFileWithStartTimeReturnsOnCall[len(fake.createMetadataFileWithStartTimeArgsForCall)]
	fake.createMetadataFileWithStartTimeArgsForCall = append(fake.createMetadataFileWithStartTimeArgsForCall, struct {
		arg1 time.Time
	}{arg1})
	stub := fake.CreateMetadataFileWithStartTimeStub
	fakeReturns := fake.createMetadataFileWithStartTimeReturns
	fake.recordInvocation("CreateMetadataFileWithStartTime", []interface{}{arg1})
	fake.createMetadataFileWithStartTimeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBackup) CreateMetadataFileWithStartTimeCallCount() int {
	fake.createMetadataFileWithStartTimeMutex.RLock()
	defer fake.createMetadataFileWithStartTimeMutex.RUnlock()
	return len(fake.createMetadataFileWithStartTimeArgsForCall)
}

func (fake *FakeBackup) CreateMetadataFileWithStartTimeCalls(stub func(time.Time) error) {
	fake.createMetadataFileWithStartTimeMutex.Lock()
	defer fake.createMetadataFileWithStartTimeMutex.Unlock()
	fake.CreateMetadataFileWithStartTimeStub = stub
}

func (fake *FakeBackup) CreateMetadataFileWithStartTimeArgsForCall(i int) time.Time {
	fake.createMetadataFileWithStartTimeMutex.RLock()
	defer fake.createMetadataFileWithStartTimeMutex.RUnlock()
	argsForCall := fake.createMetadataFileWithStartTimeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBackup) CreateMetadataFileWithStartTimeReturns(result1 error) {
	fake.createMetadataFileWithStartTimeMutex.Lock()
	defer fake.createMetadataFileWithStartTimeMutex.Unlock()
	fake.CreateMetadataFileWithStartTimeStub = nil
	fake.createMetadataFileWithStartTimeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBackup) CreateMetadataFileWithStartTimeReturnsOnCall(i int, result1 error) {
	fake.createMetadataFileWithStartTimeMutex.Lock()
	defer fake.createMetadataFileWithStartTimeMutex.Unlock()
	fake.CreateMetadataFileWithStartTimeStub = nil
	if fake.createMetadataFileWithStartTimeReturnsOnCall == nil {
		fake.createMetadataFileWithStartTimeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createMetadataFileWithStartTimeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBackup) DeploymentMatches(arg1 string, arg2 []orchestrator.Instance) (bool, error) {
	var arg2Copy []orchestrator.Instance
	if arg2 != nil {
		arg2Copy = make([]orchestrator.Instance, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.deploymentMatchesMutex.Lock()
	ret, specificReturn := fake.deploymentMatchesReturnsOnCall[len(fake.deploymentMatchesArgsForCall)]
	fake.deploymentMatchesArgsForCall = append(fake.deploymentMatchesArgsForCall, struct {
		arg1 string
		arg2 []orchestrator.Instance
	}{arg1, arg2Copy})
	stub := fake.DeploymentMatchesStub
	fakeReturns := fake.deploymentMatchesReturns
	fake.recordInvocation("DeploymentMatches", []interface{}{arg1, arg2Copy})
	fake.deploymentMatchesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBackup) DeploymentMatchesCallCount() int {
	fake.deploymentMatchesMutex.RLock()
	defer fake.deploymentMatchesMutex.RUnlock()
	return len(fake.deploymentMatchesArgsForCall)
}

func (fake *FakeBackup) DeploymentMatchesCalls(stub func(string, []orchestrator.Instance) (bool, error)) {
	fake.deploymentMatchesMutex.Lock()
	defer fake.deploymentMatchesMutex.Unlock()
	fake.DeploymentMatchesStub = stub
}

func (fake *FakeBackup) DeploymentMatchesArgsForCall(i int) (string, []orchestrator.Instance) {
	fake.deploymentMatchesMutex.RLock()
	defer fake.deploymentMatchesMutex.RUnlock()
	argsForCall := fake.deploymentMatchesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBackup) DeploymentMatchesReturns(result1 bool, result2 error) {
	fake.deploymentMatchesMutex.Lock()
	defer fake.deploymentMatchesMutex.Unlock()
	fake.DeploymentMatchesStub = nil
	fake.deploymentMatchesReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeBackup) DeploymentMatchesReturnsOnCall(i int, result1 bool, result2 error) {
	fake.deploymentMatchesMutex.Lock()
	defer fake.deploymentMatchesMutex.Unlock()
	fake.DeploymentMatchesStub = nil
	if fake.deploymentMatchesReturnsOnCall == nil {
		fake.deploymentMatchesReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.deploymentMatchesReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeBackup) FetchChecksum(arg1 orchestrator.ArtifactIdentifier) (orchestrator.BackupChecksum, error) {
	fake.fetchChecksumMutex.Lock()
	ret, specificReturn := fake.fetchChecksumReturnsOnCall[len(fake.fetchChecksumArgsForCall)]
	fake.fetchChecksumArgsForCall = append(fake.fetchChecksumArgsForCall, struct {
		arg1 orchestrator.ArtifactIdentifier
	}{arg1})
	stub := fake.FetchChecksumStub
	fakeReturns := fake.fetchChecksumReturns
	fake.recordInvocation("FetchChecksum", []interface{}{arg1})
	fake.fetchChecksumMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBackup) FetchChecksumCallCount() int {
	fake.fetchChecksumMutex.RLock()
	defer fake.fetchChecksumMutex.RUnlock()
	return len(fake.fetchChecksumArgsForCall)
}

func (fake *FakeBackup) FetchChecksumCalls(stub func(orchestrator.ArtifactIdentifier) (orchestrator.BackupChecksum, error)) {
	fake.fetchChecksumMutex.Lock()
	defer fake.fetchChecksumMutex.Unlock()
	fake.FetchChecksumStub = stub
}

func (fake *FakeBackup) FetchChecksumArgsForCall(i int) orchestrator.ArtifactIdentifier {
	fake.fetchChecksumMutex.RLock()
	defer fake.fetchChecksumMutex.RUnlock()
	argsForCall := fake.fetchChecksumArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBackup) FetchChecksumReturns(result1 orchestrator.BackupChecksum, result2 error) {
	fake.fetchChecksumMutex.Lock()
	defer fake.fetchChecksumMutex.Unlock()
	fake.FetchChecksumStub = nil
	fake.fetchChecksumReturns = struct {
		result1 orchestrator.BackupChecksum
		result2 error
	}{result1, result2}
}

func (fake *FakeBackup) FetchChecksumReturnsOnCall(i int, result1 orchestrator.BackupChecksum, result2 error) {
	fake.fetchChecksumMutex.Lock()
	defer fake.fetchChecksumMutex.Unlock()
	fake.FetchChecksumStub = nil
	if fake.fetchChecksumReturnsOnCall == nil {
		fake.fetchChecksumReturnsOnCall = make(map[int]struct {
			result1 orchestrator.BackupChecksum
			result2 error
		})
	}
	fake.fetchChecksumReturnsOnCall[i] = struct {
		result1 orchestrator.BackupChecksum
		result2 error
	}{result1, result2}
}

func (fake *FakeBackup) GetArtifactByteSize(arg1 orchestrator.ArtifactIdentifier) (int, error) {
	fake.getArtifactByteSizeMutex.Lock()
	ret, specificReturn := fake.getArtifactByteSizeReturnsOnCall[len(fake.getArtifactByteSizeArgsForCall)]
	fake.getArtifactByteSizeArgsForCall = append(fake.getArtifactByteSizeArgsForCall, struct {
		arg1 orchestrator.ArtifactIdentifier
	}{arg1})
	stub := fake.GetArtifactByteSizeStub
	fakeReturns := fake.getArtifactByteSizeReturns
	fake.recordInvocation("GetArtifactByteSize", []interface{}{arg1})
	fake.getArtifactByteSizeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBackup) GetArtifactByteSizeCallCount() int {
	fake.getArtifactByteSizeMutex.RLock()
	defer fake.getArtifactByteSizeMutex.RUnlock()
	return len(fake.getArtifactByteSizeArgsForCall)
}

func (fake *FakeBackup) GetArtifactByteSizeCalls(stub func(orchestrator.ArtifactIdentifier) (int, error)) {
	fake.getArtifactByteSizeMutex.Lock()
	defer fake.getArtifactByteSizeMutex.Unlock()
	fake.GetArtifactByteSizeStub = stub
}

func (fake *FakeBackup) GetArtifactByteSizeArgsForCall(i int) orchestrator.ArtifactIdentifier {
	fake.getArtifactByteSizeMutex.RLock()
	defer fake.getArtifactByteSizeMutex.RUnlock()
	argsForCall := fake.getArtifactByteSizeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBackup) GetArtifactByteSizeReturns(result1 int, result2 error) {
	fake.getArtifactByteSizeMutex.Lock()
	defer fake.getArtifactByteSizeMutex.Unlock()
	fake.GetArtifactByteSizeStub = nil
	fake.getArtifactByteSizeReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeBackup) GetArtifactByteSizeReturnsOnCall(i int, result1 int, result2 error) {
	fake.getArtifactByteSizeMutex.Lock()
	defer fake.getArtifactByteSizeMutex.Unlock()
	fake.GetArtifactByteSizeStub = nil
	if fake.getArtifactByteSizeReturnsOnCall == nil {
		fake.getArtifactByteSizeReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.getArtifactByteSizeReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeBackup) GetArtifactSize(arg1 orchestrator.ArtifactIdentifier) (string, error) {
	fake.getArtifactSizeMutex.Lock()
	ret, specificReturn := fake.getArtifactSizeReturnsOnCall[len(fake.getArtifactSizeArgsForCall)]
	fake.getArtifactSizeArgsForCall = append(fake.getArtifactSizeArgsForCall, struct {
		arg1 orchestrator.ArtifactIdentifier
	}{arg1})
	stub := fake.GetArtifactSizeStub
	fakeReturns := fake.getArtifactSizeReturns
	fake.recordInvocation("GetArtifactSize", []interface{}{arg1})
	fake.getArtifactSizeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBackup) GetArtifactSizeCallCount() int {
	fake.getArtifactSizeMutex.RLock()
	defer fake.getArtifactSizeMutex.RUnlock()
	return len(fake.getArtifactSizeArgsForCall)
}

func (fake *FakeBackup) GetArtifactSizeCalls(stub func(orchestrator.ArtifactIdentifier) (string, error)) {
	fake.getArtifactSizeMutex.Lock()
	defer fake.getArtifactSizeMutex.Unlock()
	fake.GetArtifactSizeStub = stub
}

func (fake *FakeBackup) GetArtifactSizeArgsForCall(i int) orchestrator.ArtifactIdentifier {
	fake.getArtifactSizeMutex.RLock()
	defer fake.getArtifactSizeMutex.RUnlock()
	argsForCall := fake.getArtifactSizeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBackup) GetArtifactSizeReturns(result1 string, result2 error) {
	fake.getArtifactSizeMutex.Lock()
	defer fake.getArtifactSizeMutex.Unlock()
	fake.GetArtifactSizeStub = nil
	fake.getArtifactSizeReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeBackup) GetArtifactSizeReturnsOnCall(i int, result1 string, result2 error) {
	fake.getArtifactSizeMutex.Lock()
	defer fake.getArtifactSizeMutex.Unlock()
	fake.GetArtifactSizeStub = nil
	if fake.getArtifactSizeReturnsOnCall == nil {
		fake.getArtifactSizeReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getArtifactSizeReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeBackup) ReadArtifact(arg1 orchestrator.ArtifactIdentifier) (io.ReadCloser, error) {
	fake.readArtifactMutex.Lock()
	ret, specificReturn := fake.readArtifactReturnsOnCall[len(fake.readArtifactArgsForCall)]
	fake.readArtifactArgsForCall = append(fake.readArtifactArgsForCall, struct {
		arg1 orchestrator.ArtifactIdentifier
	}{arg1})
	stub := fake.ReadArtifactStub
	fakeReturns := fake.readArtifactReturns
	fake.recordInvocation("ReadArtifact", []interface{}{arg1})
	fake.readArtifactMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBackup) ReadArtifactCallCount() int {
	fake.readArtifactMutex.RLock()
	defer fake.readArtifactMutex.RUnlock()
	return len(fake.readArtifactArgsForCall)
}

func (fake *FakeBackup) ReadArtifactCalls(stub func(orchestrator.ArtifactIdentifier) (io.ReadCloser, error)) {
	fake.readArtifactMutex.Lock()
	defer fake.readArtifactMutex.Unlock()
	fake.ReadArtifactStub = stub
}

func (fake *FakeBackup) ReadArtifactArgsForCall(i int) orchestrator.ArtifactIdentifier {
	fake.readArtifactMutex.RLock()
	defer fake.readArtifactMutex.RUnlock()
	argsForCall := fake.readArtifactArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBackup) ReadArtifactReturns(result1 io.ReadCloser, result2 error) {
	fake.readArtifactMutex.Lock()
	defer fake.readArtifactMutex.Unlock()
	fake.ReadArtifactStub = nil
	fake.readArtifactReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeBackup) ReadArtifactReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.readArtifactMutex.Lock()
	defer fake.readArtifactMutex.Unlock()
	fake.ReadArtifactStub = nil
	if fake.readArtifactReturnsOnCall == nil {
		fake.readArtifactReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.readArtifactReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeBackup) SaveManifest(arg1 string) error {
	fake.saveManifestMutex.Lock()
	ret, specificReturn := fake.saveManifestReturnsOnCall[len(fake.saveManifestArgsForCall)]
	fake.saveManifestArgsForCall = append(fake.saveManifestArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SaveManifestStub
	fakeReturns := fake.saveManifestReturns
	fake.recordInvocation("SaveManifest", []interface{}{arg1})
	fake.saveManifestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBackup) SaveManifestCallCount() int {
	fake.saveManifestMutex.RLock()
	defer fake.saveManifestMutex.RUnlock()
	return len(fake.saveManifestArgsForCall)
}

func (fake *FakeBackup) SaveManifestCalls(stub func(string) error) {
	fake.saveManifestMutex.Lock()
	defer fake.saveManifestMutex.Unlock()
	fake.SaveManifestStub = stub
}

func (fake *FakeBackup) SaveManifestArgsForCall(i int) string {
	fake.saveManifestMutex.RLock()
	defer fake.saveManifestMutex.RUnlock()
	argsForCall := fake.saveManifestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBackup) SaveManifestReturns(result1 error) {
	fake.saveManifestMutex.Lock()
	defer fake.saveManifestMutex.Unlock()
	fake.SaveManifestStub = nil
	fake.saveManifestReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBackup) SaveManifestReturnsOnCall(i int, result1 error) {
	fake.saveManifestMutex.Lock()
	defer fake.saveManifestMutex.Unlock()
	fake.SaveManifestStub = nil
	if fake.saveManifestReturnsOnCall == nil {
		fake.saveManifestReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveManifestReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBackup) Valid() (bool, error) {
	fake.validMutex.Lock()
	ret, specificReturn := fake.validReturnsOnCall[len(fake.validArgsForCall)]
	fake.validArgsForCall = append(fake.validArgsForCall, struct {
	}{})
	stub := fake.ValidStub
	fakeReturns := fake.validReturns
	fake.recordInvocation("Valid", []interface{}{})
	fake.validMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBackup) ValidCallCount() int {
	fake.validMutex.RLock()
	defer fake.validMutex.RUnlock()
	return len(fake.validArgsForCall)
}

func (fake *FakeBackup) ValidCalls(stub func() (bool, error)) {
	fake.validMutex.Lock()
	defer fake.validMutex.Unlock()
	fake.ValidStub = stub
}

func (fake *FakeBackup) ValidReturns(result1 bool, result2 error) {
	fake.validMutex.Lock()
	defer fake.validMutex.Unlock()
	fake.ValidStub = nil
	fake.validReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeBackup) ValidReturnsOnCall(i int, result1 bool, result2 error) {
	fake.validMutex.Lock()
	defer fake.validMutex.Unlock()
	fake.ValidStub = nil
	if fake.validReturnsOnCall == nil {
		fake.validReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.validReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeBackup) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addChecksumMutex.RLock()
	defer fake.addChecksumMutex.RUnlock()
	fake.addFinishTimeMutex.RLock()
	defer fake.addFinishTimeMutex.RUnlock()
	fake.calculateChecksumMutex.RLock()
	defer fake.calculateChecksumMutex.RUnlock()
	fake.createArtifactMutex.RLock()
	defer fake.createArtifactMutex.RUnlock()
	fake.createMetadataFileWithStartTimeMutex.RLock()
	defer fake.createMetadataFileWithStartTimeMutex.RUnlock()
	fake.deploymentMatchesMutex.RLock()
	defer fake.deploymentMatchesMutex.RUnlock()
	fake.fetchChecksumMutex.RLock()
	defer fake.fetchChecksumMutex.RUnlock()
	fake.getArtifactByteSizeMutex.RLock()
	defer fake.getArtifactByteSizeMutex.RUnlock()
	fake.getArtifactSizeMutex.RLock()
	defer fake.getArtifactSizeMutex.RUnlock()
	fake.readArtifactMutex.RLock()
	defer fake.readArtifactMutex.RUnlock()
	fake.saveManifestMutex.RLock()
	defer fake.saveManifestMutex.RUnlock()
	fake.validMutex.RLock()
	defer fake.validMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeBackup) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ orchestrator.Backup = new(FakeBackup)
