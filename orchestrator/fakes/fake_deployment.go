// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.com/cloudfoundry/bosh-backup-and-restore/executor"
	"github.com/cloudfoundry/bosh-backup-and-restore/orchestrator"
)

type FakeDeployment struct {
	BackupStub        func(executor.Executor) error
	backupMutex       sync.RWMutex
	backupArgsForCall []struct {
		arg1 executor.Executor
	}
	backupReturns struct {
		result1 error
	}
	backupReturnsOnCall map[int]struct {
		result1 error
	}
	BackupableInstancesStub        func() []orchestrator.Instance
	backupableInstancesMutex       sync.RWMutex
	backupableInstancesArgsForCall []struct {
	}
	backupableInstancesReturns struct {
		result1 []orchestrator.Instance
	}
	backupableInstancesReturnsOnCall map[int]struct {
		result1 []orchestrator.Instance
	}
	CheckArtifactDirStub        func() error
	checkArtifactDirMutex       sync.RWMutex
	checkArtifactDirArgsForCall []struct {
	}
	checkArtifactDirReturns struct {
		result1 error
	}
	checkArtifactDirReturnsOnCall map[int]struct {
		result1 error
	}
	CleanupStub        func() error
	cleanupMutex       sync.RWMutex
	cleanupArgsForCall []struct {
	}
	cleanupReturns struct {
		result1 error
	}
	cleanupReturnsOnCall map[int]struct {
		result1 error
	}
	CleanupPreviousStub        func() error
	cleanupPreviousMutex       sync.RWMutex
	cleanupPreviousArgsForCall []struct {
	}
	cleanupPreviousReturns struct {
		result1 error
	}
	cleanupPreviousReturnsOnCall map[int]struct {
		result1 error
	}
	InstancesStub        func() []orchestrator.Instance
	instancesMutex       sync.RWMutex
	instancesArgsForCall []struct {
	}
	instancesReturns struct {
		result1 []orchestrator.Instance
	}
	instancesReturnsOnCall map[int]struct {
		result1 []orchestrator.Instance
	}
	IsBackupableStub        func() bool
	isBackupableMutex       sync.RWMutex
	isBackupableArgsForCall []struct {
	}
	isBackupableReturns struct {
		result1 bool
	}
	isBackupableReturnsOnCall map[int]struct {
		result1 bool
	}
	IsRestorableStub        func() bool
	isRestorableMutex       sync.RWMutex
	isRestorableArgsForCall []struct {
	}
	isRestorableReturns struct {
		result1 bool
	}
	isRestorableReturnsOnCall map[int]struct {
		result1 bool
	}
	PostBackupUnlockStub        func(bool, orchestrator.LockOrderer, executor.Executor) error
	postBackupUnlockMutex       sync.RWMutex
	postBackupUnlockArgsForCall []struct {
		arg1 bool
		arg2 orchestrator.LockOrderer
		arg3 executor.Executor
	}
	postBackupUnlockReturns struct {
		result1 error
	}
	postBackupUnlockReturnsOnCall map[int]struct {
		result1 error
	}
	PostRestoreUnlockStub        func(orchestrator.LockOrderer, executor.Executor) error
	postRestoreUnlockMutex       sync.RWMutex
	postRestoreUnlockArgsForCall []struct {
		arg1 orchestrator.LockOrderer
		arg2 executor.Executor
	}
	postRestoreUnlockReturns struct {
		result1 error
	}
	postRestoreUnlockReturnsOnCall map[int]struct {
		result1 error
	}
	PreBackupLockStub        func(orchestrator.LockOrderer, executor.Executor) error
	preBackupLockMutex       sync.RWMutex
	preBackupLockArgsForCall []struct {
		arg1 orchestrator.LockOrderer
		arg2 executor.Executor
	}
	preBackupLockReturns struct {
		result1 error
	}
	preBackupLockReturnsOnCall map[int]struct {
		result1 error
	}
	PreRestoreLockStub        func(orchestrator.LockOrderer, executor.Executor) error
	preRestoreLockMutex       sync.RWMutex
	preRestoreLockArgsForCall []struct {
		arg1 orchestrator.LockOrderer
		arg2 executor.Executor
	}
	preRestoreLockReturns struct {
		result1 error
	}
	preRestoreLockReturnsOnCall map[int]struct {
		result1 error
	}
	RestorableInstancesStub        func() []orchestrator.Instance
	restorableInstancesMutex       sync.RWMutex
	restorableInstancesArgsForCall []struct {
	}
	restorableInstancesReturns struct {
		result1 []orchestrator.Instance
	}
	restorableInstancesReturnsOnCall map[int]struct {
		result1 []orchestrator.Instance
	}
	RestoreStub        func() error
	restoreMutex       sync.RWMutex
	restoreArgsForCall []struct {
	}
	restoreReturns struct {
		result1 error
	}
	restoreReturnsOnCall map[int]struct {
		result1 error
	}
	ValidateLockingDependenciesStub        func(orchestrator.LockOrderer) error
	validateLockingDependenciesMutex       sync.RWMutex
	validateLockingDependenciesArgsForCall []struct {
		arg1 orchestrator.LockOrderer
	}
	validateLockingDependenciesReturns struct {
		result1 error
	}
	validateLockingDependenciesReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeDeployment) Backup(arg1 executor.Executor) error {
	fake.backupMutex.Lock()
	ret, specificReturn := fake.backupReturnsOnCall[len(fake.backupArgsForCall)]
	fake.backupArgsForCall = append(fake.backupArgsForCall, struct {
		arg1 executor.Executor
	}{arg1})
	stub := fake.BackupStub
	fakeReturns := fake.backupReturns
	fake.recordInvocation("Backup", []interface{}{arg1})
	fake.backupMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDeployment) BackupCallCount() int {
	fake.backupMutex.RLock()
	defer fake.backupMutex.RUnlock()
	return len(fake.backupArgsForCall)
}

func (fake *FakeDeployment) BackupCalls(stub func(executor.Executor) error) {
	fake.backupMutex.Lock()
	defer fake.backupMutex.Unlock()
	fake.BackupStub = stub
}

func (fake *FakeDeployment) BackupArgsForCall(i int) executor.Executor {
	fake.backupMutex.RLock()
	defer fake.backupMutex.RUnlock()
	argsForCall := fake.backupArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDeployment) BackupReturns(result1 error) {
	fake.backupMutex.Lock()
	defer fake.backupMutex.Unlock()
	fake.BackupStub = nil
	fake.backupReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) BackupReturnsOnCall(i int, result1 error) {
	fake.backupMutex.Lock()
	defer fake.backupMutex.Unlock()
	fake.BackupStub = nil
	if fake.backupReturnsOnCall == nil {
		fake.backupReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.backupReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) BackupableInstances() []orchestrator.Instance {
	fake.backupableInstancesMutex.Lock()
	ret, specificReturn := fake.backupableInstancesReturnsOnCall[len(fake.backupableInstancesArgsForCall)]
	fake.backupableInstancesArgsForCall = append(fake.backupableInstancesArgsForCall, struct {
	}{})
	stub := fake.BackupableInstancesStub
	fakeReturns := fake.backupableInstancesReturns
	fake.recordInvocation("BackupableInstances", []interface{}{})
	fake.backupableInstancesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDeployment) BackupableInstancesCallCount() int {
	fake.backupableInstancesMutex.RLock()
	defer fake.backupableInstancesMutex.RUnlock()
	return len(fake.backupableInstancesArgsForCall)
}

func (fake *FakeDeployment) BackupableInstancesCalls(stub func() []orchestrator.Instance) {
	fake.backupableInstancesMutex.Lock()
	defer fake.backupableInstancesMutex.Unlock()
	fake.BackupableInstancesStub = stub
}

func (fake *FakeDeployment) BackupableInstancesReturns(result1 []orchestrator.Instance) {
	fake.backupableInstancesMutex.Lock()
	defer fake.backupableInstancesMutex.Unlock()
	fake.BackupableInstancesStub = nil
	fake.backupableInstancesReturns = struct {
		result1 []orchestrator.Instance
	}{result1}
}

func (fake *FakeDeployment) BackupableInstancesReturnsOnCall(i int, result1 []orchestrator.Instance) {
	fake.backupableInstancesMutex.Lock()
	defer fake.backupableInstancesMutex.Unlock()
	fake.BackupableInstancesStub = nil
	if fake.backupableInstancesReturnsOnCall == nil {
		fake.backupableInstancesReturnsOnCall = make(map[int]struct {
			result1 []orchestrator.Instance
		})
	}
	fake.backupableInstancesReturnsOnCall[i] = struct {
		result1 []orchestrator.Instance
	}{result1}
}

func (fake *FakeDeployment) CheckArtifactDir() error {
	fake.checkArtifactDirMutex.Lock()
	ret, specificReturn := fake.checkArtifactDirReturnsOnCall[len(fake.checkArtifactDirArgsForCall)]
	fake.checkArtifactDirArgsForCall = append(fake.checkArtifactDirArgsForCall, struct {
	}{})
	stub := fake.CheckArtifactDirStub
	fakeReturns := fake.checkArtifactDirReturns
	fake.recordInvocation("CheckArtifactDir", []interface{}{})
	fake.checkArtifactDirMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDeployment) CheckArtifactDirCallCount() int {
	fake.checkArtifactDirMutex.RLock()
	defer fake.checkArtifactDirMutex.RUnlock()
	return len(fake.checkArtifactDirArgsForCall)
}

func (fake *FakeDeployment) CheckArtifactDirCalls(stub func() error) {
	fake.checkArtifactDirMutex.Lock()
	defer fake.checkArtifactDirMutex.Unlock()
	fake.CheckArtifactDirStub = stub
}

func (fake *FakeDeployment) CheckArtifactDirReturns(result1 error) {
	fake.checkArtifactDirMutex.Lock()
	defer fake.checkArtifactDirMutex.Unlock()
	fake.CheckArtifactDirStub = nil
	fake.checkArtifactDirReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) CheckArtifactDirReturnsOnCall(i int, result1 error) {
	fake.checkArtifactDirMutex.Lock()
	defer fake.checkArtifactDirMutex.Unlock()
	fake.CheckArtifactDirStub = nil
	if fake.checkArtifactDirReturnsOnCall == nil {
		fake.checkArtifactDirReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.checkArtifactDirReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) Cleanup() error {
	fake.cleanupMutex.Lock()
	ret, specificReturn := fake.cleanupReturnsOnCall[len(fake.cleanupArgsForCall)]
	fake.cleanupArgsForCall = append(fake.cleanupArgsForCall, struct {
	}{})
	stub := fake.CleanupStub
	fakeReturns := fake.cleanupReturns
	fake.recordInvocation("Cleanup", []interface{}{})
	fake.cleanupMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDeployment) CleanupCallCount() int {
	fake.cleanupMutex.RLock()
	defer fake.cleanupMutex.RUnlock()
	return len(fake.cleanupArgsForCall)
}

func (fake *FakeDeployment) CleanupCalls(stub func() error) {
	fake.cleanupMutex.Lock()
	defer fake.cleanupMutex.Unlock()
	fake.CleanupStub = stub
}

func (fake *FakeDeployment) CleanupReturns(result1 error) {
	fake.cleanupMutex.Lock()
	defer fake.cleanupMutex.Unlock()
	fake.CleanupStub = nil
	fake.cleanupReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) CleanupReturnsOnCall(i int, result1 error) {
	fake.cleanupMutex.Lock()
	defer fake.cleanupMutex.Unlock()
	fake.CleanupStub = nil
	if fake.cleanupReturnsOnCall == nil {
		fake.cleanupReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cleanupReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) CleanupPrevious() error {
	fake.cleanupPreviousMutex.Lock()
	ret, specificReturn := fake.cleanupPreviousReturnsOnCall[len(fake.cleanupPreviousArgsForCall)]
	fake.cleanupPreviousArgsForCall = append(fake.cleanupPreviousArgsForCall, struct {
	}{})
	stub := fake.CleanupPreviousStub
	fakeReturns := fake.cleanupPreviousReturns
	fake.recordInvocation("CleanupPrevious", []interface{}{})
	fake.cleanupPreviousMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDeployment) CleanupPreviousCallCount() int {
	fake.cleanupPreviousMutex.RLock()
	defer fake.cleanupPreviousMutex.RUnlock()
	return len(fake.cleanupPreviousArgsForCall)
}

func (fake *FakeDeployment) CleanupPreviousCalls(stub func() error) {
	fake.cleanupPreviousMutex.Lock()
	defer fake.cleanupPreviousMutex.Unlock()
	fake.CleanupPreviousStub = stub
}

func (fake *FakeDeployment) CleanupPreviousReturns(result1 error) {
	fake.cleanupPreviousMutex.Lock()
	defer fake.cleanupPreviousMutex.Unlock()
	fake.CleanupPreviousStub = nil
	fake.cleanupPreviousReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) CleanupPreviousReturnsOnCall(i int, result1 error) {
	fake.cleanupPreviousMutex.Lock()
	defer fake.cleanupPreviousMutex.Unlock()
	fake.CleanupPreviousStub = nil
	if fake.cleanupPreviousReturnsOnCall == nil {
		fake.cleanupPreviousReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cleanupPreviousReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) Instances() []orchestrator.Instance {
	fake.instancesMutex.Lock()
	ret, specificReturn := fake.instancesReturnsOnCall[len(fake.instancesArgsForCall)]
	fake.instancesArgsForCall = append(fake.instancesArgsForCall, struct {
	}{})
	stub := fake.InstancesStub
	fakeReturns := fake.instancesReturns
	fake.recordInvocation("Instances", []interface{}{})
	fake.instancesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDeployment) InstancesCallCount() int {
	fake.instancesMutex.RLock()
	defer fake.instancesMutex.RUnlock()
	return len(fake.instancesArgsForCall)
}

func (fake *FakeDeployment) InstancesCalls(stub func() []orchestrator.Instance) {
	fake.instancesMutex.Lock()
	defer fake.instancesMutex.Unlock()
	fake.InstancesStub = stub
}

func (fake *FakeDeployment) InstancesReturns(result1 []orchestrator.Instance) {
	fake.instancesMutex.Lock()
	defer fake.instancesMutex.Unlock()
	fake.InstancesStub = nil
	fake.instancesReturns = struct {
		result1 []orchestrator.Instance
	}{result1}
}

func (fake *FakeDeployment) InstancesReturnsOnCall(i int, result1 []orchestrator.Instance) {
	fake.instancesMutex.Lock()
	defer fake.instancesMutex.Unlock()
	fake.InstancesStub = nil
	if fake.instancesReturnsOnCall == nil {
		fake.instancesReturnsOnCall = make(map[int]struct {
			result1 []orchestrator.Instance
		})
	}
	fake.instancesReturnsOnCall[i] = struct {
		result1 []orchestrator.Instance
	}{result1}
}

func (fake *FakeDeployment) IsBackupable() bool {
	fake.isBackupableMutex.Lock()
	ret, specificReturn := fake.isBackupableReturnsOnCall[len(fake.isBackupableArgsForCall)]
	fake.isBackupableArgsForCall = append(fake.isBackupableArgsForCall, struct {
	}{})
	stub := fake.IsBackupableStub
	fakeReturns := fake.isBackupableReturns
	fake.recordInvocation("IsBackupable", []interface{}{})
	fake.isBackupableMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDeployment) IsBackupableCallCount() int {
	fake.isBackupableMutex.RLock()
	defer fake.isBackupableMutex.RUnlock()
	return len(fake.isBackupableArgsForCall)
}

func (fake *FakeDeployment) IsBackupableCalls(stub func() bool) {
	fake.isBackupableMutex.Lock()
	defer fake.isBackupableMutex.Unlock()
	fake.IsBackupableStub = stub
}

func (fake *FakeDeployment) IsBackupableReturns(result1 bool) {
	fake.isBackupableMutex.Lock()
	defer fake.isBackupableMutex.Unlock()
	fake.IsBackupableStub = nil
	fake.isBackupableReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeDeployment) IsBackupableReturnsOnCall(i int, result1 bool) {
	fake.isBackupableMutex.Lock()
	defer fake.isBackupableMutex.Unlock()
	fake.IsBackupableStub = nil
	if fake.isBackupableReturnsOnCall == nil {
		fake.isBackupableReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isBackupableReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeDeployment) IsRestorable() bool {
	fake.isRestorableMutex.Lock()
	ret, specificReturn := fake.isRestorableReturnsOnCall[len(fake.isRestorableArgsForCall)]
	fake.isRestorableArgsForCall = append(fake.isRestorableArgsForCall, struct {
	}{})
	stub := fake.IsRestorableStub
	fakeReturns := fake.isRestorableReturns
	fake.recordInvocation("IsRestorable", []interface{}{})
	fake.isRestorableMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDeployment) IsRestorableCallCount() int {
	fake.isRestorableMutex.RLock()
	defer fake.isRestorableMutex.RUnlock()
	return len(fake.isRestorableArgsForCall)
}

func (fake *FakeDeployment) IsRestorableCalls(stub func() bool) {
	fake.isRestorableMutex.Lock()
	defer fake.isRestorableMutex.Unlock()
	fake.IsRestorableStub = stub
}

func (fake *FakeDeployment) IsRestorableReturns(result1 bool) {
	fake.isRestorableMutex.Lock()
	defer fake.isRestorableMutex.Unlock()
	fake.IsRestorableStub = nil
	fake.isRestorableReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeDeployment) IsRestorableReturnsOnCall(i int, result1 bool) {
	fake.isRestorableMutex.Lock()
	defer fake.isRestorableMutex.Unlock()
	fake.IsRestorableStub = nil
	if fake.isRestorableReturnsOnCall == nil {
		fake.isRestorableReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isRestorableReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeDeployment) PostBackupUnlock(arg1 bool, arg2 orchestrator.LockOrderer, arg3 executor.Executor) error {
	fake.postBackupUnlockMutex.Lock()
	ret, specificReturn := fake.postBackupUnlockReturnsOnCall[len(fake.postBackupUnlockArgsForCall)]
	fake.postBackupUnlockArgsForCall = append(fake.postBackupUnlockArgsForCall, struct {
		arg1 bool
		arg2 orchestrator.LockOrderer
		arg3 executor.Executor
	}{arg1, arg2, arg3})
	stub := fake.PostBackupUnlockStub
	fakeReturns := fake.postBackupUnlockReturns
	fake.recordInvocation("PostBackupUnlock", []interface{}{arg1, arg2, arg3})
	fake.postBackupUnlockMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDeployment) PostBackupUnlockCallCount() int {
	fake.postBackupUnlockMutex.RLock()
	defer fake.postBackupUnlockMutex.RUnlock()
	return len(fake.postBackupUnlockArgsForCall)
}

func (fake *FakeDeployment) PostBackupUnlockCalls(stub func(bool, orchestrator.LockOrderer, executor.Executor) error) {
	fake.postBackupUnlockMutex.Lock()
	defer fake.postBackupUnlockMutex.Unlock()
	fake.PostBackupUnlockStub = stub
}

func (fake *FakeDeployment) PostBackupUnlockArgsForCall(i int) (bool, orchestrator.LockOrderer, executor.Executor) {
	fake.postBackupUnlockMutex.RLock()
	defer fake.postBackupUnlockMutex.RUnlock()
	argsForCall := fake.postBackupUnlockArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDeployment) PostBackupUnlockReturns(result1 error) {
	fake.postBackupUnlockMutex.Lock()
	defer fake.postBackupUnlockMutex.Unlock()
	fake.PostBackupUnlockStub = nil
	fake.postBackupUnlockReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) PostBackupUnlockReturnsOnCall(i int, result1 error) {
	fake.postBackupUnlockMutex.Lock()
	defer fake.postBackupUnlockMutex.Unlock()
	fake.PostBackupUnlockStub = nil
	if fake.postBackupUnlockReturnsOnCall == nil {
		fake.postBackupUnlockReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.postBackupUnlockReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) PostRestoreUnlock(arg1 orchestrator.LockOrderer, arg2 executor.Executor) error {
	fake.postRestoreUnlockMutex.Lock()
	ret, specificReturn := fake.postRestoreUnlockReturnsOnCall[len(fake.postRestoreUnlockArgsForCall)]
	fake.postRestoreUnlockArgsForCall = append(fake.postRestoreUnlockArgsForCall, struct {
		arg1 orchestrator.LockOrderer
		arg2 executor.Executor
	}{arg1, arg2})
	stub := fake.PostRestoreUnlockStub
	fakeReturns := fake.postRestoreUnlockReturns
	fake.recordInvocation("PostRestoreUnlock", []interface{}{arg1, arg2})
	fake.postRestoreUnlockMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDeployment) PostRestoreUnlockCallCount() int {
	fake.postRestoreUnlockMutex.RLock()
	defer fake.postRestoreUnlockMutex.RUnlock()
	return len(fake.postRestoreUnlockArgsForCall)
}

func (fake *FakeDeployment) PostRestoreUnlockCalls(stub func(orchestrator.LockOrderer, executor.Executor) error) {
	fake.postRestoreUnlockMutex.Lock()
	defer fake.postRestoreUnlockMutex.Unlock()
	fake.PostRestoreUnlockStub = stub
}

func (fake *FakeDeployment) PostRestoreUnlockArgsForCall(i int) (orchestrator.LockOrderer, executor.Executor) {
	fake.postRestoreUnlockMutex.RLock()
	defer fake.postRestoreUnlockMutex.RUnlock()
	argsForCall := fake.postRestoreUnlockArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDeployment) PostRestoreUnlockReturns(result1 error) {
	fake.postRestoreUnlockMutex.Lock()
	defer fake.postRestoreUnlockMutex.Unlock()
	fake.PostRestoreUnlockStub = nil
	fake.postRestoreUnlockReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) PostRestoreUnlockReturnsOnCall(i int, result1 error) {
	fake.postRestoreUnlockMutex.Lock()
	defer fake.postRestoreUnlockMutex.Unlock()
	fake.PostRestoreUnlockStub = nil
	if fake.postRestoreUnlockReturnsOnCall == nil {
		fake.postRestoreUnlockReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.postRestoreUnlockReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) PreBackupLock(arg1 orchestrator.LockOrderer, arg2 executor.Executor) error {
	fake.preBackupLockMutex.Lock()
	ret, specificReturn := fake.preBackupLockReturnsOnCall[len(fake.preBackupLockArgsForCall)]
	fake.preBackupLockArgsForCall = append(fake.preBackupLockArgsForCall, struct {
		arg1 orchestrator.LockOrderer
		arg2 executor.Executor
	}{arg1, arg2})
	stub := fake.PreBackupLockStub
	fakeReturns := fake.preBackupLockReturns
	fake.recordInvocation("PreBackupLock", []interface{}{arg1, arg2})
	fake.preBackupLockMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDeployment) PreBackupLockCallCount() int {
	fake.preBackupLockMutex.RLock()
	defer fake.preBackupLockMutex.RUnlock()
	return len(fake.preBackupLockArgsForCall)
}

func (fake *FakeDeployment) PreBackupLockCalls(stub func(orchestrator.LockOrderer, executor.Executor) error) {
	fake.preBackupLockMutex.Lock()
	defer fake.preBackupLockMutex.Unlock()
	fake.PreBackupLockStub = stub
}

func (fake *FakeDeployment) PreBackupLockArgsForCall(i int) (orchestrator.LockOrderer, executor.Executor) {
	fake.preBackupLockMutex.RLock()
	defer fake.preBackupLockMutex.RUnlock()
	argsForCall := fake.preBackupLockArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDeployment) PreBackupLockReturns(result1 error) {
	fake.preBackupLockMutex.Lock()
	defer fake.preBackupLockMutex.Unlock()
	fake.PreBackupLockStub = nil
	fake.preBackupLockReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) PreBackupLockReturnsOnCall(i int, result1 error) {
	fake.preBackupLockMutex.Lock()
	defer fake.preBackupLockMutex.Unlock()
	fake.PreBackupLockStub = nil
	if fake.preBackupLockReturnsOnCall == nil {
		fake.preBackupLockReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.preBackupLockReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) PreRestoreLock(arg1 orchestrator.LockOrderer, arg2 executor.Executor) error {
	fake.preRestoreLockMutex.Lock()
	ret, specificReturn := fake.preRestoreLockReturnsOnCall[len(fake.preRestoreLockArgsForCall)]
	fake.preRestoreLockArgsForCall = append(fake.preRestoreLockArgsForCall, struct {
		arg1 orchestrator.LockOrderer
		arg2 executor.Executor
	}{arg1, arg2})
	stub := fake.PreRestoreLockStub
	fakeReturns := fake.preRestoreLockReturns
	fake.recordInvocation("PreRestoreLock", []interface{}{arg1, arg2})
	fake.preRestoreLockMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDeployment) PreRestoreLockCallCount() int {
	fake.preRestoreLockMutex.RLock()
	defer fake.preRestoreLockMutex.RUnlock()
	return len(fake.preRestoreLockArgsForCall)
}

func (fake *FakeDeployment) PreRestoreLockCalls(stub func(orchestrator.LockOrderer, executor.Executor) error) {
	fake.preRestoreLockMutex.Lock()
	defer fake.preRestoreLockMutex.Unlock()
	fake.PreRestoreLockStub = stub
}

func (fake *FakeDeployment) PreRestoreLockArgsForCall(i int) (orchestrator.LockOrderer, executor.Executor) {
	fake.preRestoreLockMutex.RLock()
	defer fake.preRestoreLockMutex.RUnlock()
	argsForCall := fake.preRestoreLockArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDeployment) PreRestoreLockReturns(result1 error) {
	fake.preRestoreLockMutex.Lock()
	defer fake.preRestoreLockMutex.Unlock()
	fake.PreRestoreLockStub = nil
	fake.preRestoreLockReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) PreRestoreLockReturnsOnCall(i int, result1 error) {
	fake.preRestoreLockMutex.Lock()
	defer fake.preRestoreLockMutex.Unlock()
	fake.PreRestoreLockStub = nil
	if fake.preRestoreLockReturnsOnCall == nil {
		fake.preRestoreLockReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.preRestoreLockReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) RestorableInstances() []orchestrator.Instance {
	fake.restorableInstancesMutex.Lock()
	ret, specificReturn := fake.restorableInstancesReturnsOnCall[len(fake.restorableInstancesArgsForCall)]
	fake.restorableInstancesArgsForCall = append(fake.restorableInstancesArgsForCall, struct {
	}{})
	stub := fake.RestorableInstancesStub
	fakeReturns := fake.restorableInstancesReturns
	fake.recordInvocation("RestorableInstances", []interface{}{})
	fake.restorableInstancesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDeployment) RestorableInstancesCallCount() int {
	fake.restorableInstancesMutex.RLock()
	defer fake.restorableInstancesMutex.RUnlock()
	return len(fake.restorableInstancesArgsForCall)
}

func (fake *FakeDeployment) RestorableInstancesCalls(stub func() []orchestrator.Instance) {
	fake.restorableInstancesMutex.Lock()
	defer fake.restorableInstancesMutex.Unlock()
	fake.RestorableInstancesStub = stub
}

func (fake *FakeDeployment) RestorableInstancesReturns(result1 []orchestrator.Instance) {
	fake.restorableInstancesMutex.Lock()
	defer fake.restorableInstancesMutex.Unlock()
	fake.RestorableInstancesStub = nil
	fake.restorableInstancesReturns = struct {
		result1 []orchestrator.Instance
	}{result1}
}

func (fake *FakeDeployment) RestorableInstancesReturnsOnCall(i int, result1 []orchestrator.Instance) {
	fake.restorableInstancesMutex.Lock()
	defer fake.restorableInstancesMutex.Unlock()
	fake.RestorableInstancesStub = nil
	if fake.restorableInstancesReturnsOnCall == nil {
		fake.restorableInstancesReturnsOnCall = make(map[int]struct {
			result1 []orchestrator.Instance
		})
	}
	fake.restorableInstancesReturnsOnCall[i] = struct {
		result1 []orchestrator.Instance
	}{result1}
}

func (fake *FakeDeployment) Restore() error {
	fake.restoreMutex.Lock()
	ret, specificReturn := fake.restoreReturnsOnCall[len(fake.restoreArgsForCall)]
	fake.restoreArgsForCall = append(fake.restoreArgsForCall, struct {
	}{})
	stub := fake.RestoreStub
	fakeReturns := fake.restoreReturns
	fake.recordInvocation("Restore", []interface{}{})
	fake.restoreMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDeployment) RestoreCallCount() int {
	fake.restoreMutex.RLock()
	defer fake.restoreMutex.RUnlock()
	return len(fake.restoreArgsForCall)
}

func (fake *FakeDeployment) RestoreCalls(stub func() error) {
	fake.restoreMutex.Lock()
	defer fake.restoreMutex.Unlock()
	fake.RestoreStub = stub
}

func (fake *FakeDeployment) RestoreReturns(result1 error) {
	fake.restoreMutex.Lock()
	defer fake.restoreMutex.Unlock()
	fake.RestoreStub = nil
	fake.restoreReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) RestoreReturnsOnCall(i int, result1 error) {
	fake.restoreMutex.Lock()
	defer fake.restoreMutex.Unlock()
	fake.RestoreStub = nil
	if fake.restoreReturnsOnCall == nil {
		fake.restoreReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.restoreReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) ValidateLockingDependencies(arg1 orchestrator.LockOrderer) error {
	fake.validateLockingDependenciesMutex.Lock()
	ret, specificReturn := fake.validateLockingDependenciesReturnsOnCall[len(fake.validateLockingDependenciesArgsForCall)]
	fake.validateLockingDependenciesArgsForCall = append(fake.validateLockingDependenciesArgsForCall, struct {
		arg1 orchestrator.LockOrderer
	}{arg1})
	stub := fake.ValidateLockingDependenciesStub
	fakeReturns := fake.validateLockingDependenciesReturns
	fake.recordInvocation("ValidateLockingDependencies", []interface{}{arg1})
	fake.validateLockingDependenciesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDeployment) ValidateLockingDependenciesCallCount() int {
	fake.validateLockingDependenciesMutex.RLock()
	defer fake.validateLockingDependenciesMutex.RUnlock()
	return len(fake.validateLockingDependenciesArgsForCall)
}

func (fake *FakeDeployment) ValidateLockingDependenciesCalls(stub func(orchestrator.LockOrderer) error) {
	fake.validateLockingDependenciesMutex.Lock()
	defer fake.validateLockingDependenciesMutex.Unlock()
	fake.ValidateLockingDependenciesStub = stub
}

func (fake *FakeDeployment) ValidateLockingDependenciesArgsForCall(i int) orchestrator.LockOrderer {
	fake.validateLockingDependenciesMutex.RLock()
	defer fake.validateLockingDependenciesMutex.RUnlock()
	argsForCall := fake.validateLockingDependenciesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDeployment) ValidateLockingDependenciesReturns(result1 error) {
	fake.validateLockingDependenciesMutex.Lock()
	defer fake.validateLockingDependenciesMutex.Unlock()
	fake.ValidateLockingDependenciesStub = nil
	fake.validateLockingDependenciesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) ValidateLockingDependenciesReturnsOnCall(i int, result1 error) {
	fake.validateLockingDependenciesMutex.Lock()
	defer fake.validateLockingDependenciesMutex.Unlock()
	fake.ValidateLockingDependenciesStub = nil
	if fake.validateLockingDependenciesReturnsOnCall == nil {
		fake.validateLockingDependenciesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.validateLockingDependenciesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.backupMutex.RLock()
	defer fake.backupMutex.RUnlock()
	fake.backupableInstancesMutex.RLock()
	defer fake.backupableInstancesMutex.RUnlock()
	fake.checkArtifactDirMutex.RLock()
	defer fake.checkArtifactDirMutex.RUnlock()
	fake.cleanupMutex.RLock()
	defer fake.cleanupMutex.RUnlock()
	fake.cleanupPreviousMutex.RLock()
	defer fake.cleanupPreviousMutex.RUnlock()
	fake.instancesMutex.RLock()
	defer fake.instancesMutex.RUnlock()
	fake.isBackupableMutex.RLock()
	defer fake.isBackupableMutex.RUnlock()
	fake.isRestorableMutex.RLock()
	defer fake.isRestorableMutex.RUnlock()
	fake.postBackupUnlockMutex.RLock()
	defer fake.postBackupUnlockMutex.RUnlock()
	fake.postRestoreUnlockMutex.RLock()
	defer fake.postRestoreUnlockMutex.RUnlock()
	fake.preBackupLockMutex.RLock()
	defer fake.preBackupLockMutex.RUnlock()
	fake.preRestoreLockMutex.RLock()
	defer fake.preRestoreLockMutex.RUnlock()
	fake.restorableInstancesMutex.RLock()
	defer fake.restorableInstancesMutex.RUnlock()
	fake.restoreMutex.RLock()
	defer fake.restoreMutex.RUnlock()
	fake.validateLockingDependenciesMutex.RLock()
	defer fake.validateLockingDependenciesMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeDeployment) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ orchestrator.Deployment = new(FakeDeployment)
