// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"io"
	"sync"

	"github.com/cloudfoundry/bosh-backup-and-restore/orchestrator"
)

type FakeBackupArtifact struct {
	ChecksumStub        func() (orchestrator.BackupChecksum, error)
	checksumMutex       sync.RWMutex
	checksumArgsForCall []struct {
	}
	checksumReturns struct {
		result1 orchestrator.BackupChecksum
		result2 error
	}
	checksumReturnsOnCall map[int]struct {
		result1 orchestrator.BackupChecksum
		result2 error
	}
	DeleteStub        func() error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
	}
	deleteReturns struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	HasCustomNameStub        func() bool
	hasCustomNameMutex       sync.RWMutex
	hasCustomNameArgsForCall []struct {
	}
	hasCustomNameReturns struct {
		result1 bool
	}
	hasCustomNameReturnsOnCall map[int]struct {
		result1 bool
	}
	InstanceIDStub        func() string
	instanceIDMutex       sync.RWMutex
	instanceIDArgsForCall []struct {
	}
	instanceIDReturns struct {
		result1 string
	}
	instanceIDReturnsOnCall map[int]struct {
		result1 string
	}
	InstanceIndexStub        func() string
	instanceIndexMutex       sync.RWMutex
	instanceIndexArgsForCall []struct {
	}
	instanceIndexReturns struct {
		result1 string
	}
	instanceIndexReturnsOnCall map[int]struct {
		result1 string
	}
	InstanceNameStub        func() string
	instanceNameMutex       sync.RWMutex
	instanceNameArgsForCall []struct {
	}
	instanceNameReturns struct {
		result1 string
	}
	instanceNameReturnsOnCall map[int]struct {
		result1 string
	}
	NameStub        func() string
	nameMutex       sync.RWMutex
	nameArgsForCall []struct {
	}
	nameReturns struct {
		result1 string
	}
	nameReturnsOnCall map[int]struct {
		result1 string
	}
	SizeStub        func() (string, error)
	sizeMutex       sync.RWMutex
	sizeArgsForCall []struct {
	}
	sizeReturns struct {
		result1 string
		result2 error
	}
	sizeReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	SizeInBytesStub        func() (int, error)
	sizeInBytesMutex       sync.RWMutex
	sizeInBytesArgsForCall []struct {
	}
	sizeInBytesReturns struct {
		result1 int
		result2 error
	}
	sizeInBytesReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	StreamFromRemoteStub        func(io.Writer) error
	streamFromRemoteMutex       sync.RWMutex
	streamFromRemoteArgsForCall []struct {
		arg1 io.Writer
	}
	streamFromRemoteReturns struct {
		result1 error
	}
	streamFromRemoteReturnsOnCall map[int]struct {
		result1 error
	}
	StreamToRemoteStub        func(io.Reader) error
	streamToRemoteMutex       sync.RWMutex
	streamToRemoteArgsForCall []struct {
		arg1 io.Reader
	}
	streamToRemoteReturns struct {
		result1 error
	}
	streamToRemoteReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeBackupArtifact) Checksum() (orchestrator.BackupChecksum, error) {
	fake.checksumMutex.Lock()
	ret, specificReturn := fake.checksumReturnsOnCall[len(fake.checksumArgsForCall)]
	fake.checksumArgsForCall = append(fake.checksumArgsForCall, struct {
	}{})
	stub := fake.ChecksumStub
	fakeReturns := fake.checksumReturns
	fake.recordInvocation("Checksum", []interface{}{})
	fake.checksumMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBackupArtifact) ChecksumCallCount() int {
	fake.checksumMutex.RLock()
	defer fake.checksumMutex.RUnlock()
	return len(fake.checksumArgsForCall)
}

func (fake *FakeBackupArtifact) ChecksumCalls(stub func() (orchestrator.BackupChecksum, error)) {
	fake.checksumMutex.Lock()
	defer fake.checksumMutex.Unlock()
	fake.ChecksumStub = stub
}

func (fake *FakeBackupArtifact) ChecksumReturns(result1 orchestrator.BackupChecksum, result2 error) {
	fake.checksumMutex.Lock()
	defer fake.checksumMutex.Unlock()
	fake.ChecksumStub = nil
	fake.checksumReturns = struct {
		result1 orchestrator.BackupChecksum
		result2 error
	}{result1, result2}
}

func (fake *FakeBackupArtifact) ChecksumReturnsOnCall(i int, result1 orchestrator.BackupChecksum, result2 error) {
	fake.checksumMutex.Lock()
	defer fake.checksumMutex.Unlock()
	fake.ChecksumStub = nil
	if fake.checksumReturnsOnCall == nil {
		fake.checksumReturnsOnCall = make(map[int]struct {
			result1 orchestrator.BackupChecksum
			result2 error
		})
	}
	fake.checksumReturnsOnCall[i] = struct {
		result1 orchestrator.BackupChecksum
		result2 error
	}{result1, result2}
}

func (fake *FakeBackupArtifact) Delete() error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
	}{})
	stub := fake.DeleteStub
	fakeReturns := fake.deleteReturns
	fake.recordInvocation("Delete", []interface{}{})
	fake.deleteMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBackupArtifact) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeBackupArtifact) DeleteCalls(stub func() error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = stub
}

func (fake *FakeBackupArtifact) DeleteReturns(result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBackupArtifact) DeleteReturnsOnCall(i int, result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBackupArtifact) HasCustomName() bool {
	fake.hasCustomNameMutex.Lock()
	ret, specificReturn := fake.hasCustomNameReturnsOnCall[len(fake.hasCustomNameArgsForCall)]
	fake.hasCustomNameArgsForCall = append(fake.hasCustomNameArgsForCall, struct {
	}{})
	stub := fake.HasCustomNameStub
	fakeReturns := fake.hasCustomNameReturns
	fake.recordInvocation("HasCustomName", []interface{}{})
	fake.hasCustomNameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBackupArtifact) HasCustomNameCallCount() int {
	fake.hasCustomNameMutex.RLock()
	defer fake.hasCustomNameMutex.RUnlock()
	return len(fake.hasCustomNameArgsForCall)
}

func (fake *FakeBackupArtifact) HasCustomNameCalls(stub func() bool) {
	fake.hasCustomNameMutex.Lock()
	defer fake.hasCustomNameMutex.Unlock()
	fake.HasCustomNameStub = stub
}

func (fake *FakeBackupArtifact) HasCustomNameReturns(result1 bool) {
	fake.hasCustomNameMutex.Lock()
	defer fake.hasCustomNameMutex.Unlock()
	fake.HasCustomNameStub = nil
	fake.hasCustomNameReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBackupArtifact) HasCustomNameReturnsOnCall(i int, result1 bool) {
	fake.hasCustomNameMutex.Lock()
	defer fake.hasCustomNameMutex.Unlock()
	fake.HasCustomNameStub = nil
	if fake.hasCustomNameReturnsOnCall == nil {
		fake.hasCustomNameReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.hasCustomNameReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBackupArtifact) InstanceID() string {
	fake.instanceIDMutex.Lock()
	ret, specificReturn := fake.instanceIDReturnsOnCall[len(fake.instanceIDArgsForCall)]
	fake.instanceIDArgsForCall = append(fake.instanceIDArgsForCall, struct {
	}{})
	stub := fake.InstanceIDStub
	fakeReturns := fake.instanceIDReturns
	fake.recordInvocation("InstanceID", []interface{}{})
	fake.instanceIDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBackupArtifact) InstanceIDCallCount() int {
	fake.instanceIDMutex.RLock()
	defer fake.instanceIDMutex.RUnlock()
	return len(fake.instanceIDArgsForCall)
}

func (fake *FakeBackupArtifact) InstanceIDCalls(stub func() string) {
	fake.instanceIDMutex.Lock()
	defer fake.instanceIDMutex.Unlock()
	fake.InstanceIDStub = stub
}

func (fake *FakeBackupArtifact) InstanceIDReturns(result1 string) {
	fake.instanceIDMutex.Lock()
	defer fake.instanceIDMutex.Unlock()
	fake.InstanceIDStub = nil
	fake.instanceIDReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeBackupArtifact) InstanceIDReturnsOnCall(i int, result1 string) {
	fake.instanceIDMutex.Lock()
	defer fake.instanceIDMutex.Unlock()
	fake.InstanceIDStub = nil
	if fake.instanceIDReturnsOnCall == nil {
		fake.instanceIDReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.instanceIDReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeBackupArtifact) InstanceIndex() string {
	fake.instanceIndexMutex.Lock()
	ret, specificReturn := fake.instanceIndexReturnsOnCall[len(fake.instanceIndexArgsForCall)]
	fake.instanceIndexArgsForCall = append(fake.instanceIndexArgsForCall, struct {
	}{})
	stub := fake.InstanceIndexStub
	fakeReturns := fake.instanceIndexReturns
	fake.recordInvocation("InstanceIndex", []interface{}{})
	fake.instanceIndexMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBackupArtifact) InstanceIndexCallCount() int {
	fake.instanceIndexMutex.RLock()
	defer fake.instanceIndexMutex.RUnlock()
	return len(fake.instanceIndexArgsForCall)
}

func (fake *FakeBackupArtifact) InstanceIndexCalls(stub func() string) {
	fake.instanceIndexMutex.Lock()
	defer fake.instanceIndexMutex.Unlock()
	fake.InstanceIndexStub = stub
}

func (fake *FakeBackupArtifact) InstanceIndexReturns(result1 string) {
	fake.instanceIndexMutex.Lock()
	defer fake.instanceIndexMutex.Unlock()
	fake.InstanceIndexStub = nil
	fake.instanceIndexReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeBackupArtifact) InstanceIndexReturnsOnCall(i int, result1 string) {
	fake.instanceIndexMutex.Lock()
	defer fake.instanceIndexMutex.Unlock()
	fake.InstanceIndexStub = nil
	if fake.instanceIndexReturnsOnCall == nil {
		fake.instanceIndexReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.instanceIndexReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeBackupArtifact) InstanceName() string {
	fake.instanceNameMutex.Lock()
	ret, specificReturn := fake.instanceNameReturnsOnCall[len(fake.instanceNameArgsForCall)]
	fake.instanceNameArgsForCall = append(fake.instanceNameArgsForCall, struct {
	}{})
	stub := fake.InstanceNameStub
	fakeReturns := fake.instanceNameReturns
	fake.recordInvocation("InstanceName", []interface{}{})
	fake.instanceNameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBackupArtifact) InstanceNameCallCount() int {
	fake.instanceNameMutex.RLock()
	defer fake.instanceNameMutex.RUnlock()
	return len(fake.instanceNameArgsForCall)
}

func (fake *FakeBackupArtifact) InstanceNameCalls(stub func() string) {
	fake.instanceNameMutex.Lock()
	defer fake.instanceNameMutex.Unlock()
	fake.InstanceNameStub = stub
}

func (fake *FakeBackupArtifact) InstanceNameReturns(result1 string) {
	fake.instanceNameMutex.Lock()
	defer fake.instanceNameMutex.Unlock()
	fake.InstanceNameStub = nil
	fake.instanceNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeBackupArtifact) InstanceNameReturnsOnCall(i int, result1 string) {
	fake.instanceNameMutex.Lock()
	defer fake.instanceNameMutex.Unlock()
	fake.InstanceNameStub = nil
	if fake.instanceNameReturnsOnCall == nil {
		fake.instanceNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.instanceNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeBackupArtifact) Name() string {
	fake.nameMutex.Lock()
	ret, specificReturn := fake.nameReturnsOnCall[len(fake.nameArgsForCall)]
	fake.nameArgsForCall = append(fake.nameArgsForCall, struct {
	}{})
	stub := fake.NameStub
	fakeReturns := fake.nameReturns
	fake.recordInvocation("Name", []interface{}{})
	fake.nameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBackupArtifact) NameCallCount() int {
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	return len(fake.nameArgsForCall)
}

func (fake *FakeBackupArtifact) NameCalls(stub func() string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = stub
}

func (fake *FakeBackupArtifact) NameReturns(result1 string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = nil
	fake.nameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeBackupArtifact) NameReturnsOnCall(i int, result1 string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = nil
	if fake.nameReturnsOnCall == nil {
		fake.nameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.nameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeBackupArtifact) Size() (string, error) {
	fake.sizeMutex.Lock()
	ret, specificReturn := fake.sizeReturnsOnCall[len(fake.sizeArgsForCall)]
	fake.sizeArgsForCall = append(fake.sizeArgsForCall, struct {
	}{})
	stub := fake.SizeStub
	fakeReturns := fake.sizeReturns
	fake.recordInvocation("Size", []interface{}{})
	fake.sizeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBackupArtifact) SizeCallCount() int {
	fake.sizeMutex.RLock()
	defer fake.sizeMutex.RUnlock()
	return len(fake.sizeArgsForCall)
}

func (fake *FakeBackupArtifact) SizeCalls(stub func() (string, error)) {
	fake.sizeMutex.Lock()
	defer fake.sizeMutex.Unlock()
	fake.SizeStub = stub
}

func (fake *FakeBackupArtifact) SizeReturns(result1 string, result2 error) {
	fake.sizeMutex.Lock()
	defer fake.sizeMutex.Unlock()
	fake.SizeStub = nil
	fake.sizeReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeBackupArtifact) SizeReturnsOnCall(i int, result1 string, result2 error) {
	fake.sizeMutex.Lock()
	defer fake.sizeMutex.Unlock()
	fake.SizeStub = nil
	if fake.sizeReturnsOnCall == nil {
		fake.sizeReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.sizeReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeBackupArtifact) SizeInBytes() (int, error) {
	fake.sizeInBytesMutex.Lock()
	ret, specificReturn := fake.sizeInBytesReturnsOnCall[len(fake.sizeInBytesArgsForCall)]
	fake.sizeInBytesArgsForCall = append(fake.sizeInBytesArgsForCall, struct {
	}{})
	stub := fake.SizeInBytesStub
	fakeReturns := fake.sizeInBytesReturns
	fake.recordInvocation("SizeInBytes", []interface{}{})
	fake.sizeInBytesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBackupArtifact) SizeInBytesCallCount() int {
	fake.sizeInBytesMutex.RLock()
	defer fake.sizeInBytesMutex.RUnlock()
	return len(fake.sizeInBytesArgsForCall)
}

func (fake *FakeBackupArtifact) SizeInBytesCalls(stub func() (int, error)) {
	fake.sizeInBytesMutex.Lock()
	defer fake.sizeInBytesMutex.Unlock()
	fake.SizeInBytesStub = stub
}

func (fake *FakeBackupArtifact) SizeInBytesReturns(result1 int, result2 error) {
	fake.sizeInBytesMutex.Lock()
	defer fake.sizeInBytesMutex.Unlock()
	fake.SizeInBytesStub = nil
	fake.sizeInBytesReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeBackupArtifact) SizeInBytesReturnsOnCall(i int, result1 int, result2 error) {
	fake.sizeInBytesMutex.Lock()
	defer fake.sizeInBytesMutex.Unlock()
	fake.SizeInBytesStub = nil
	if fake.sizeInBytesReturnsOnCall == nil {
		fake.sizeInBytesReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.sizeInBytesReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeBackupArtifact) StreamFromRemote(arg1 io.Writer) error {
	fake.streamFromRemoteMutex.Lock()
	ret, specificReturn := fake.streamFromRemoteReturnsOnCall[len(fake.streamFromRemoteArgsForCall)]
	fake.streamFromRemoteArgsForCall = append(fake.streamFromRemoteArgsForCall, struct {
		arg1 io.Writer
	}{arg1})
	stub := fake.StreamFromRemoteStub
	fakeReturns := fake.streamFromRemoteReturns
	fake.recordInvocation("StreamFromRemote", []interface{}{arg1})
	fake.streamFromRemoteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBackupArtifact) StreamFromRemoteCallCount() int {
	fake.streamFromRemoteMutex.RLock()
	defer fake.streamFromRemoteMutex.RUnlock()
	return len(fake.streamFromRemoteArgsForCall)
}

func (fake *FakeBackupArtifact) StreamFromRemoteCalls(stub func(io.Writer) error) {
	fake.streamFromRemoteMutex.Lock()
	defer fake.streamFromRemoteMutex.Unlock()
	fake.StreamFromRemoteStub = stub
}

func (fake *FakeBackupArtifact) StreamFromRemoteArgsForCall(i int) io.Writer {
	fake.streamFromRemoteMutex.RLock()
	defer fake.streamFromRemoteMutex.RUnlock()
	argsForCall := fake.streamFromRemoteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBackupArtifact) StreamFromRemoteReturns(result1 error) {
	fake.streamFromRemoteMutex.Lock()
	defer fake.streamFromRemoteMutex.Unlock()
	fake.StreamFromRemoteStub = nil
	fake.streamFromRemoteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBackupArtifact) StreamFromRemoteReturnsOnCall(i int, result1 error) {
	fake.streamFromRemoteMutex.Lock()
	defer fake.streamFromRemoteMutex.Unlock()
	fake.StreamFromRemoteStub = nil
	if fake.streamFromRemoteReturnsOnCall == nil {
		fake.streamFromRemoteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.streamFromRemoteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBackupArtifact) StreamToRemote(arg1 io.Reader) error {
	fake.streamToRemoteMutex.Lock()
	ret, specificReturn := fake.streamToRemoteReturnsOnCall[len(fake.streamToRemoteArgsForCall)]
	fake.streamToRemoteArgsForCall = append(fake.streamToRemoteArgsForCall, struct {
		arg1 io.Reader
	}{arg1})
	stub := fake.StreamToRemoteStub
	fakeReturns := fake.streamToRemoteReturns
	fake.recordInvocation("StreamToRemote", []interface{}{arg1})
	fake.streamToRemoteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBackupArtifact) StreamToRemoteCallCount() int {
	fake.streamToRemoteMutex.RLock()
	defer fake.streamToRemoteMutex.RUnlock()
	return len(fake.streamToRemoteArgsForCall)
}

func (fake *FakeBackupArtifact) StreamToRemoteCalls(stub func(io.Reader) error) {
	fake.streamToRemoteMutex.Lock()
	defer fake.streamToRemoteMutex.Unlock()
	fake.StreamToRemoteStub = stub
}

func (fake *FakeBackupArtifact) StreamToRemoteArgsForCall(i int) io.Reader {
	fake.streamToRemoteMutex.RLock()
	defer fake.streamToRemoteMutex.RUnlock()
	argsForCall := fake.streamToRemoteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBackupArtifact) StreamToRemoteReturns(result1 error) {
	fake.streamToRemoteMutex.Lock()
	defer fake.streamToRemoteMutex.Unlock()
	fake.StreamToRemoteStub = nil
	fake.streamToRemoteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBackupArtifact) StreamToRemoteReturnsOnCall(i int, result1 error) {
	fake.streamToRemoteMutex.Lock()
	defer fake.streamToRemoteMutex.Unlock()
	fake.StreamToRemoteStub = nil
	if fake.streamToRemoteReturnsOnCall == nil {
		fake.streamToRemoteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.streamToRemoteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBackupArtifact) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.checksumMutex.RLock()
	defer fake.checksumMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.hasCustomNameMutex.RLock()
	defer fake.hasCustomNameMutex.RUnlock()
	fake.instanceIDMutex.RLock()
	defer fake.instanceIDMutex.RUnlock()
	fake.instanceIndexMutex.RLock()
	defer fake.instanceIndexMutex.RUnlock()
	fake.instanceNameMutex.RLock()
	defer fake.instanceNameMutex.RUnlock()
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	fake.sizeMutex.RLock()
	defer fake.sizeMutex.RUnlock()
	fake.sizeInBytesMutex.RLock()
	defer fake.sizeInBytesMutex.RUnlock()
	fake.streamFromRemoteMutex.RLock()
	defer fake.streamFromRemoteMutex.RUnlock()
	fake.streamToRemoteMutex.RLock()
	defer fake.streamToRemoteMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeBackupArtifact) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ orchestrator.BackupArtifact = new(FakeBackupArtifact)
